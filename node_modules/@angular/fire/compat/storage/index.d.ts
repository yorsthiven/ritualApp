import * as i0 from '@angular/core';
import { Injector, InjectionToken, NgZone, PipeTransform, OnDestroy, ChangeDetectorRef, TransferState } from '@angular/core';
import { Observable } from 'rxjs';
import firebase from 'firebase/compat/app';
import * as _angular_fire_compat_storage from '@angular/fire/compat/storage';
import { ɵAngularFireSchedulers as _AngularFireSchedulers } from '@angular/fire';
import { AppCheckInstances } from '@angular/fire/app-check';
import { FirebaseOptions } from 'firebase/app';
import * as firebase_compat from 'firebase/compat';

type UploadTask = firebase.storage.UploadTask;
type UploadTaskSnapshot = firebase.storage.UploadTaskSnapshot;
type UploadMetadata = firebase.storage.UploadMetadata;
type SettableMetadata = firebase.storage.SettableMetadata;
type Reference = firebase.storage.Reference;
type ListResult = firebase.storage.ListResult;
type ListOptions = firebase.storage.ListOptions;

interface AngularFireUploadTask {
    task: UploadTask;
    snapshotChanges(): Observable<UploadTaskSnapshot | undefined>;
    percentageChanges(): Observable<number | undefined>;
    pause(): boolean;
    cancel(): boolean;
    resume(): boolean;
    then(onFulfilled?: ((a: UploadTaskSnapshot) => any) | null, onRejected?: ((a: Error) => any) | null): Promise<any>;
    catch(onRejected: (a: Error) => any): Promise<any>;
}
/**
 * Create an AngularFireUploadTask from a regular UploadTask from the Storage SDK.
 * This method creates an observable of the upload and returns on object that provides
 * multiple methods for controlling and monitoring the file upload.
 */
declare function createUploadTask(task: UploadTask): AngularFireUploadTask;

interface AngularFireStorageReference {
    getDownloadURL(): Observable<any>;
    getMetadata(): Observable<any>;
    delete(): Observable<any>;
    child(path: string): AngularFireStorageReference;
    updateMetadata(meta: SettableMetadata): Observable<any>;
    put(data: any, metadata?: UploadMetadata | undefined): AngularFireUploadTask;
    putString(data: string, format?: string | undefined, metadata?: UploadMetadata | undefined): AngularFireUploadTask;
    list(options?: ListOptions): Observable<ListResult>;
    listAll(): Observable<ListResult>;
}
/**
 * Create an AngularFire wrapped Storage Reference. This object
 * creates observable methods from promise based methods.
 */
declare function createStorageRef(ref: Reference, injector?: Injector): AngularFireStorageReference;

declare const BUCKET: InjectionToken<string>;
declare const MAX_UPLOAD_RETRY_TIME: InjectionToken<number>;
declare const MAX_OPERATION_RETRY_TIME: InjectionToken<number>;
declare const USE_EMULATOR: InjectionToken<[host: string, port: number, options?: {
    mockUserToken?: firebase.EmulatorMockTokenOptions | string;
}]>;
/**
 * AngularFireStorage Service
 *
 * This service is the main entry point for this feature module. It provides
 * an API for uploading and downloading binary files from Cloud Storage for
 * Firebase.
 */
declare class AngularFireStorage {
    readonly storage: firebase.storage.Storage;
    private readonly injector;
    constructor(options: FirebaseOptions, name: string | null | undefined, storageBucket: string | null, platformId: Object, zone: NgZone, schedulers: _AngularFireSchedulers, maxUploadRetryTime: any, maxOperationRetryTime: any, _useEmulator: any, _appCheckInstances: AppCheckInstances);
    ref(path: string): AngularFireStorageReference;
    refFromURL(path: string): AngularFireStorageReference;
    upload(path: string, data: any, metadata?: UploadMetadata): _angular_fire_compat_storage.AngularFireUploadTask;
    static ɵfac: i0.ɵɵFactoryDeclaration<AngularFireStorage, [null, { optional: true; }, { optional: true; }, null, null, null, { optional: true; }, { optional: true; }, { optional: true; }, { optional: true; }]>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AngularFireStorage>;
}

declare function fromTask(task: UploadTask): Observable<firebase_compat.default.storage.UploadTaskSnapshot>;

/** to be used with in combination with | async */
declare class GetDownloadURLPipe implements PipeTransform, OnDestroy {
    private storage;
    private state;
    private asyncPipe;
    private path;
    private downloadUrl$;
    constructor(storage: AngularFireStorage, cdr: ChangeDetectorRef, state: TransferState);
    transform(path: string): any;
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<GetDownloadURLPipe, [null, null, { optional: true; }]>;
    static ɵpipe: i0.ɵɵPipeDeclaration<GetDownloadURLPipe, "getDownloadURL", true>;
}
declare class GetDownloadURLPipeModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<GetDownloadURLPipeModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<GetDownloadURLPipeModule, never, [typeof GetDownloadURLPipe], [typeof GetDownloadURLPipe]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<GetDownloadURLPipeModule>;
}

declare class AngularFireStorageModule {
    constructor();
    static ɵfac: i0.ɵɵFactoryDeclaration<AngularFireStorageModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<AngularFireStorageModule, never, [typeof GetDownloadURLPipeModule], [typeof GetDownloadURLPipeModule]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<AngularFireStorageModule>;
}

export { AngularFireStorage, AngularFireStorageModule, BUCKET, GetDownloadURLPipe, GetDownloadURLPipeModule, MAX_OPERATION_RETRY_TIME, MAX_UPLOAD_RETRY_TIME, USE_EMULATOR, createStorageRef, createUploadTask, fromTask };
export type { AngularFireStorageReference, AngularFireUploadTask };
